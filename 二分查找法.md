# 前提 
- 已经排序
- 已知目标
# 复杂度  
O(logn) O(1)  
# 流程  
先确认目标在不在数列中，在则取左边界，优边界与中点，通过不断比较目标值与中点的大小，移动左右边界再推算中点，并且进行下一次比较，移动....直到中点即时我们要的值。  
# 注意事项  
- 移动边界时必须把上一次比较后确认的全部筛掉的值排除在下一次边界外。（middle,middle-1的易错点）
- 边界是左闭右闭还是单个闭，我们移动边界时要不要考虑左右点相等情况（需要考虑移动后区间是否为空集问题）
# 模板  
- 左闭右闭
```
int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
```
-左闭右开
```
 int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
       return -1;
```
# 例题
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
*这里插入点是个难点。可以这么想*
*二分中退出while循环条件是l>r，若想实现这一点必须满足的是middle值在l或在r上，然后另一边界移动到m-1或m+1上。分别考虑若在l/r上两种情况，枚举发现插入点都在最后一次移动后l值上*
*以上是[]型，[)型为r值，按上面思路自己推一下*
