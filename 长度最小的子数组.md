# 二分查找、滑动窗口（我感觉还是双指针）
# 题目
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
# 滑动窗口
## 思路
右指针遍历，累计和，每一次遍历都while判断是否sum>=tatget,如果是就开始输出两指针中间的长度值，并比较哦是否为最小值，同时，左指针往右前进，直达不大于等于目标值。<br>
## 代码实现
```
int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;

```
- INT32_MAX是32位能到的最大数，利用它可以实现声明一个最大的int型。
- 习惯使用三元运算符替代if else语句提高效率
- sum-=nums（i--）这个快一点，也要习惯使用
# 二分
## 思路
利用前缀和数组（原数组第i个元素前的元素和构成的新数组）（因此比原数组长度多一），和nums（r）-nums(l)>=s，所以s+nums（l）<=nums(r),那么s+nums(l)就是在左指针为i时满足这一条件的理想nums(r)值，二分查找第一个大于等于他的值，也便是最小数组情况下的r值，这样一点点遍历最后找出最小值。<br>
## 代码
```
int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        vector<int> sums(n + 1, 0); 
        // 为了方便计算，令 size = n + 1 
        // sums[0] = 0 意味着前 0 个元素的前缀和为 0
        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]
        // 以此类推
        for (int i = 1; i <= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
        for (int i = 1; i <= n; i++) {
            int target = s + sums[i - 1];
            auto bound = lower_bound(sums.begin(), sums.end(), target);
            if (bound != sums.end()) {
                ans = min(ans, static_cast<int>((bound - sums.begin()) - (i - 1)));
            }
        }
        return ans == INT_MAX ? 0 : ans;
```
- bound_lower是二分查找第一个大于等于目标值的的函数。语法：bound_lower(起，终，目标值)
- 需要区分的一点是，数组位置坐标用指针描述，运用到像begin()运算的位置数据类型是ptrdiff_t，我的建议是这种运算之类的全用auto型。而迭代器是容器（c++）用的，他对应的数据类型是difference_type,问题但不大，都可以用万能的auto;但要注意，我们要的值是int型，所以这里进行了一个类型转换
- static_cast<int>()是c++风格的类型转换，我们这里也可以用(int)，c风格的转换方式
